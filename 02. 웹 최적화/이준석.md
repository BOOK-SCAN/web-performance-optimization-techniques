# **📝 Contents**

## **웹 최적화란**

- 최고의 웹 성능을 구현하기 위해 최고의 조건을 만드는 것

### 프론트엔드 최적화

- 웹 UI/UX와 관련된 최적화
- 프론트 최적화가 잘되어있으면 브라우저에서 콘텐츠 다운, 로딩, 렌더링 속도가 빨라짐
- 브라우징 시간에서 상당수가 프론트 엔드에서 차지 ⇒ 웹성능은 프론트엔드에 좌우됨
- 프론트 엔드 최적화는 사용자 환경에 따라 달라지므로 상대적으로 적용해야함

### 벡엔드 촤적화

- 웹 UI를 로직에 맞게 만드는 벡엔드 최적화
- 웹 서버, 웹 애플리케이션 서버, 데이터 베이스, 로드 벨런싱, DNS 서버 등
- 프론트엔드 최적화에 비해 가시적인 효과는 적지만 빠른 로딩보다 정상적인 콘텐츠 전달을 위해 반드시 필요한 요소

### 프로토콜 촤적화

- 웹 콘텐츠를 전달하는 HTTP/HTTPS 프로토콜 자체를 최적화
- 최대속도와 최저 지연시간으로 전달 가능

## TCP/IP 프로토콜

- TPC 네트워크의 성능 지표
    - 대역폭 : 특정 시간동안 얼마나 많은 네트워크 트래픽을 보낼 수 있는 지 시간당 전송량
    - 지연 시간  : 클라이언트와 서버 간 콘텐츠를 전달하는 물리적인 시간
        
        (RTT(Round Trip TIme): 서버와 클라이언트를 왕복하는데 걸리는 지연시간)
        

### TCP 혼잡 제어

- TCP 네트워크의 통신량을 조절하여 TCP 네트워크가 혼잡해지지 않도록 하는 방식
- 느린 시작
    - TCP 연결이 시작되면, 전송가능버퍼의 양을 작게 설정하고, ACK를 받으면 패킷 유실이 발생하기 전까지 2배씩 늘리는 방법
    - 패킷 유실이 발생하면 다시 최소 크기로 줄인다.
    - 전송가능버퍼가 임계점에 도달하면 그때부턴 1씩 늘린다.
      <img width="784" alt="스크린샷 2024-11-11 오후 1 06 15" src="https://github.com/user-attachments/assets/4bc583a0-f0dd-462d-8aa0-671840d78a64">

       
      


- 빠른 재전송
    - 먼저 받아야할 패킷이 도착하지 않고 다음 패킷이 와도 ACK를 보내는 방법
    - 다음 패킷을 받으면 받지 못한 이전 패킷의 ACK를 제대로 받을때까지 다시 보낸다.
    - 송신측은 중복 ACK를 3번 받으면 반드시 손실된 패킷을 보낸다.
      <img width="778" alt="스크린샷 2024-11-11 오후 1 02 37" src="https://github.com/user-attachments/assets/b78672be-7bbd-41aa-ab19-26242e9a6a5e">
      

- 흐름 제어
    - 송신자가 너무 빠르거나 많이 전송해 수신자의 버퍼가 오버플로우 되는 것을 막는 것
    - 수신자는 수신 버퍼를 가지고 상위 애플리케이션 프로세스의 읽는 속도에 맞게 보낸다.
    - 이 속도에 맞춰 송신자가 데이터를 보내는 기술

## HTTP 프로토콜

### HTTP 최적화 기술

- HTTP/0.9 : 클라이언트-서버의 인터넷 통신 정상화, 가용성, 신뢰성에 초점
- HTTP/1.0 : 클라이언트-서버 사이 요청과 응답을 빠르게 하는 기술 연구
- HTTP/1.1 : 멀티 호스트 기능과 클라이언트-서버 사이 TCP/IP 연결 재사용 기능 추가

### HTTP 지속적 연결

- 기존의 TCP/IP에서 3-wat handshake는 한번 전송이 이루어지면 연결이 끊어진다.
- 계속 데이터를 주고받게 하기 위해서, 완전히 끊기 전까지는 연결을 유지하는 기술을 개발
- 처음에는 헤더에 Connection: keep alive 속성을 넣으면 유지하도록 개발
- 이후에는 지속적 연결을 기본값으로 하고, 연결을 끊으며면 Connection : Close를 넣는 방식으로 변경
- 서버에 클라이언트들이 계속 TCP 연결 되면 자원이 고갈될 수 있으므로 서버의 성능을 고려해 지속적 연결을 설정해야함

### HTTP 파이프라이닝

- 먼저 보낸 요청의 응답이 없어도 다음 요청을 병렬적으로 전송하는 기술
- 응답지연이 발생해도 다른 응답을 받을 수 있어 빠른 웹 로딩이 가능

## DNS (Domain Name System)

- 인터넷 호스트 명을 클라이언트와 서버가 이해할 수 있는 IP 주소로 변환해주는 시스템

### DNS 작동 원리
<img width="784" alt="스크린샷 2024-11-11 오후 1 16 01" src="https://github.com/user-attachments/assets/7119f86f-e5e7-4ef0-9b43-48bfa9109d39">



1. 로컬 DNS 서버로 질의 : 만약 찾는 IP주소가 캐시되어 남아있다면 바로 전달, 없으면 다음 단계로
2. 루트 DNS 서버로 질의 : ICANN이 직접 관리하는 절대 존엄 서버로, TLD DNS 서버 IP들을 저장해두고 찾는 IP주소에 따라 안내한다.
3. TLD DNS 서버(최상위 도메인 서버)로 질의 : .com 도메인을 관장하는 서버로, Authoritative DNS 서버 주소를 저장해두고 찾는 IP주소에 따라 안내한다.
4. Authoritative DNS 서버로 질의 : 실제 개인 도메인과 IP 주소의 관계가 기록/저장/변경되는 서버로, 찾는 IP주소를 알려준다.
- 이런 프로세스를 반복적 질의 라고 한다.

### 웹 성능 최적화하는 도메인 운용 방법

- 내부 서비스의 도메인을 분할하고 싶다면 상위 도메인을 동일하게 해 DNS 질의를 최대한 적게 만드는 것을 권장
- 동일한 상위 도메인 사용시 HTTPS 사용을 위한 SSL 인증서를 와일드 카드 형식으로 하나만 생성해도 모든 도메인에 사용할 수 있음
- HTML의 DNS 프리페치 기능 : 하나의 웹 페이지에 여러 도메인 호스트명이 있을 경우 웹 문서를 여는 시점에 멀티스레드 방식으로 미리 DNS 조회해 빠르게 IP주소를 불러오는 방식

## 브라우저

### 브라우저의 역사와 특징

- 처음에는 HTTP로 웹 서버에 접속해 단순한 콘텐츠를 가져오는 기능
- MS의 internet explorer 3 부터 css와 오디오 기능 추가
- 비디오 형식의 멀티미디어 요소에 맞춘 HTML 5와 CSS 3.0이 개발
- 현재 최신 브라우저들은 HTML, CSS, AJAX등 최신 기술 대부분 지원

### 네비게이션 타이밍 API

- 웹사이트의 성능을 측정하는 데 사용할 수 있는 데이터 제공

# **💭 Insights**
