# 📝 Contents

- 웹 사이트는 검색 엔진 최적화(SEO)를 실행하면 좀 더 빠르게 검색된다.
- 검색 엔진 최적화가 실행된 웹 사이트는 다른 사이트에 비해 자주 상단에 노출되어 많은 방문자를 이끌어내므로 결국 웹 사이트 홍보 또는 웹 사이트를 통한 수익 창출에 도움이 된다.

### 웹 최적화란
- 웹 최적화: 최고의 웹 성능을 구현하기 위해 최고의 조건을 만드는 다양한 노력

#### 프론트엔드 최적화
- 웹 UI/UX와 관련된 최적화
- 프론트엔드 최적화 기술은 웹 브라우저를 실제로 사용하는 사용자 환경에 따라 달라진다.
- 프론트엔드를 최적화하는 대표적 기술은 다음과 같다.
  + 스크립트를 병합하여 브라우저의 호출 개수를 줄임
  + 스크립트 크기를 최소화해 바이트 자체를 줄임
  + 스크립트를 gzip 등으로 압축하여 전달
  + WebP 등으로 브라우저 이미지 형식을 최적화
  + 이미지 손실, 무손실 압축
  + Cache-Control 응답 헤더를 통해 브라우저 캐시를 충실히 사용
  + 도메인 수를 줄여 DNS 조회를 최소화
  + DNS 정보 미리 읽어 오기
  + CSS를 HTML 상단에, 자바스크립트를 HTML의 하단에 위치시키기
  + 페이지 미리 읽어오기
  + 타사 스크립트가 웹 성능을 방해하지 않도록 조정
 
#### 백엔드 최적화
- 웹 UI를 로직에 맞게 만드는 백엔드 관련 최적화
- 백엔드 시스템들을 튜닝해 정상 출력을 만드는 것이 백엔드를 최적화하는 목표
- 백엔드를 최적화하는 대표적 방법은 다음과 같다.
  + DNS 응답이 빨라지도록 서버 증설
  + DNS 응답을 빠르게 할 수 있도록 DNS 정보를 최대한 캐싱
  + 웹 서버가 있는 데이터 센터의 네트워크 출력/대역폭 증설
  + 웹 서버, 엡 애플리케이션 서버의 CPU/RAM 증설
  + 프록시 서버를 설정하여 웹 콘텐츠를 캐싱
  + CDN(Content Delivery Network)을 사용해 인터넷상에 콘텐츠 캐싱
  + 데이터베이스 정규화로 디스크 I/O 최적화
  + 데이터베이스 캐싱으로 응답을 빠르게
  + 로드 밸런싱을 통해 가장 성능이 좋은 웹 서버로 요청을 연결
  + 웹 애플리케이션 로직을 가볍고 빠르게 개발
- 백엔드 최적화는 프론트엔드 최적화에 비해 가시적인 효과가 크지 않지만 웹 사이트의 빠른 로딩보다 네트워크를 정상적으로 사용하고 콘텐츠를 전달하기 위해 반드시 필요한 요소이다.

#### 프로토콜 최적화
- 웹 콘텐츠를 전달하는 HTTP/HTTPS 프로토콜 자체의 효과를 극대화하면 웹 서버가 클라이언트에게 콘텐츠를 최대 속도와 최저 지연 시간으로 전달할 수 있다.
- 프로토콜 최적화: 웹 콘텐츠를 더 빠르게 요청하고 응답하도록 프로토콜을 업드레이드하는 과정

### TCP/TP 프로토콜
- TCP 네트워크를 사용하는 네트워크에 있어 대표적인 성능 지표: 대역폭, 지연 시간
  + 대역폭: 특정 시간 동안 얼마나 많은 네트워크 트래픽을 보낼 수 있는지 시간당 전송량을 의미
    + 예) 크기가 큰 이미지 파일을 다운로드하려면 완료 시간은 클라이언트와 서버 사이 대역폭에 영향을 받음
  + 지연 시간: 클라이언트와 서버 간 콘텐츠를 전달하는 물리적인 시간
    + 일반적으로는 클라이언트와 서버 사이 요청, 전달, 응답까지 걸리는 시간
    + 브라우저가 콘텐츠를 해석하고 화면에 렌더링하는 단계는 클라이언트 측에서만 실행하므로 지연 시간에는 포함되지 않음
- Round Trip Time(RTT): 서버와 클라이언트 두 호스트를 모두 왕복하는 데 걸리는 지연 시간
  + 이 값은 인터넷상에서의 게임을 즐기거나 화상 채팅 등을 할 때 품질에 영향을 준다.
  + 따라서 스트리밍 서비스 관련 회사들은 지연 시간이 길고 짧음에 따라 전달받는 영상 파일의 품질을 조절하여 버퍼링을 줄일 수 있는 가변 스트리밍 방식을 사용한다.

#### TCP 혼잡 제어
- TCP 혼잡 제어: TCP 네트워크의 통신량을 조절하여 TCP 네트워크가 혼잡해지지 않도록 하는 방식
- TCP 혼잡 붕괴: TCP 네트워크의 통신량이 실제 처리량보다 많아서 문제가 발생하는 것
  + 인터넷에 연결된 호스트들이 최대한 많은 정보를 전송하려고 많은 네트워크 패킷을 보내기 때문에 발생
- 패킷을 보내는 쪽에서 네트워크에서 수용할 수 있는 양을 파악하고 그만큼의 패킷만 보내는 약속으로 TCP 혼잡을 해결한다.
  + 받는 쪽은 패킷이 정상적으로 송신되었음을 알리는 ACK 패킷을 보내며 ACK 패킷을 받은 호스트는 지속적으로 패킷을 보낼 수 있다.
- 호스트가 네트워크의 상태를 시시각각 파악하고 전송 속도를 조절하는 것 또한 혼잡 제어 기능 중 하나이다.
- 혼잡 제어의 대표 기술들은 다음과 같다.
  + 느린 시작(slow start): TCP 연결이 시작되면 전송 가능한 버퍼의 양인 혼잡 윈도우(SWND)의 초깃값을 작게 설정하여 전송한다.
    + 즉, 패킷이 정상적으로 도착할 때마다 더 많은 패킷을 보내고, 이를 패킷 유실이 발생하기 전까지 반복하는 방식
    + 초기에는 적은 패킷을 보내면서 곱셈 방식으로 전송 패킷의 크기를 빠르게 늘리는 방법
    + 이 기술을 통해 혼잡 윈도우의 크기를 파악하면 그 이상의 패킷을 보내지 않는다.
  + 빠른 재전송: 먼저 도착해야 하는 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 수신자가 일단 ACK 패킷을 보내는 방식
    + 중간에 패킷이 하나 손실되면 송신자는 중복된 ACK 패킷을 통해 이를 감지하고 성장적으로 전송되지 않은 패킷을 재전송한다.
  + 흐름 제어: TCP 송신자가 데이터를 너무 빠르게 혹은 너무 많이 전송하여 수신자의 버퍼가 오버플로되는 현상을 방지하는 기술
    + 송신자가 데이터를 전송하는 속도를 애플리케이션 프로세스를 읽는 속도와 유사한 수준으로 만들어 트래픽 수신 속도를 송신 속도와 일치시키는 기술

### HTTP 프로토콜
- HTTP: 텍스트 이상 콘텐츠들을 웹에서 전달하기 위해 만들어진 프로토콜
- 웹은 HTTP 프로토콜을 통해 전달되므로 HTTP 성능을 개선하면 웹 성능도 향상된다.

#### HTTP 최적화 기술
- HTTP/0.9 버전 탄생 이후 HTTP/3 버전이 등장할 때까지 HTTP는 크게 여섯 차례 업데이트했다.
- HTTP/0.9 버전까지 클라이언트와 서버의 인터넷 통신 정상화, 가용성, 신뢰성 등 기능에 초점을 두었다면 HTTP/1.0 버전부터는 클라이언트와 서버 사이 요청과 응답을 빠르게 할 수 있는 연구가 진행되었다.
  + 웹 환경이 멀티호스트 환경으로 변하면서 HTTP/1.1 버전부터 멀티호스트 기능과 클라이언트와 서버 사이에서 TCP/IP 연결을 재사용하는 기능을 추가한 것이 두드러진 업데이트 내용
- 연결 기반의 HTTP 최적화 기술: 연결 재사용, 파이프라이닝 기법

#### HTTP 지속적 연결
- TCP의 통신을 연결하는 3-way handshake 방식은 클라이언트와 서버 사이 SYN, SYN-ACK, ACK의 3번의 요청과 응답으로 이루어진다.
  + 이 방식은 송신자와 수신자 사이 신뢰할 수 있는 안전한 통신을 추구하는 TCP 알고리즘에서 시작되었지만 동시에 많은 웹 콘텐츠를 전달해야 하는 HTTP 통신에서 번거로움이 발생했다.
  + 콘텐츠 수가 점점 다양해지면서 TCP 연결을 맺고 끊는 것이 웹 성능에 걸림돌이 되었다.
- 웹 사이트에 이미지 등의 멀티미디어 콘텐츠가 늘어나면서 TCP 연결 재사용이 필요하게 되어 등장한 것이 지속적 연결 기술
- keep-alive 혹은 연결 재사용이라는 용어로도 불리는 지속적 연결 방식 등장 전후 HTTP와 TCP 연결 변화는 아래 그림을 통해 비교 할수 있다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbfHrRM%2Fbtq5tEr0fkD%2FVGbFEVID66U0HJhYg1lemk%2Fimg.png" width="500" height="300"/>

- HTTP 지속적 연결은 오른쪽처럼 클라이언트와 서버가 TCP상에서 한 번 연결되면 둘 사이의 연결이 완전하게 끊어지기 전까지 맺어진 연결을 지속적으로 재사용하는 기술
- HTTP/1.0 기반에서는 HTTP 요청 헤더를 이용하여 Connection 헤더 및 keep-alive 속성으로 지속적인 연결을 요청하기 시작했다.
  + `Connection: keep-aive`
  + HTTP/1.1 버전에서는 Connection 헤더를 사용하지 않아도 모든 요청과 응답이 HTTP 지속적 연결을 기본으로 지원해서, HTTP 응답이 완료되거나 TCP 연결을 끊어야 할 때만 Connection 헤더를 사용했다.
- curl 명령문: HTTP 요청과 응답을 브라우저와 유사하게 커맨드 라인 형식으로 실행할 수 있는 애플리케이션
  + 간단한 HTTP 요청이나 웹 서버의 응답을 헤더와 페이로드로 나누어 자세히 살펴볼 때 유용
- 웹 사이트의 메인 페이지와 같이 많은 클라이언트가 접속하는 페이지에서는 서버의 성능을 고려해 HTTP 지속적 연결 기능을 사용할지 결정해야 한다.
  + HTTP 지속적 연결을 사용함으로써 단일 시간 동안 TCP 연결의 수를 줄여 서버의 CPU나 메모리 자원을 절약하고 네트워크 혼잡이나 지연을 줄이는 장점이 있다.

#### HTTP 파이프라이닝
- HTTP 파이프라이닝 기술 개발은 HTTP 선입 선출 방식의 단점을 극복하는 데서 출발하였다.
- HTTP 파이프라이닝: 먼저 보낸 요청의 응답이 없어도 다음 요청을 병렬적으로 수신자 측에 전송하는 기술
  + 따라서 중간에서 응답 지연이 발생하더라도 클라이언트는 먼저 서버 측의 응답을 받을 수 있어 전체적으로 빠른 웹 로딩이 구현되는 구조

### DNS
- DNS: 인터넷 호스트명을 클라이언트와 서버가 이해할 수 있는 IP 주소로 변환해주는 시스템
  + IP 주소로 만들어진 웹 사이트를 운영할 때는 DNS가 필요하지 않지만, 대부분 웹 서비스는 사용자가 기억하기 쉬운 호스트명을 인터넷 주소로 사용한다.
- DNS 질의와 응답 성능이 나쁘면 웹 사이트 로딩에 영향을 줄 수 있다.

#### DNS의 작동 원리
- DNS 질의 과정을 살펴보면 도메인을 IP 주소로 질의하여 값을 받아오는 과정에는 하나의 DNS 서버가 아니라 도메인 구조 계층에 따라 각각의 DNS 서버들이 관여한다.
  + 반복적 질의: 계층형으로 나누어진 역할에 따라 순차적인 DNS 질의를 반복하여 값을 받아오는 프로세스 과정
- DNS 서버들의 속도가 느리거나 제때 응답을 주지 못하면 결국 전반적인 웹 성능에 영향을 미친다.
  + 로컬 DNS 서버들은 ISP 업체나 DNS 전문 서비스 업체 등이 관리
  + 루트 DNS 서버는 ICANN 기관에서 관리

#### 사용 중인 다양한 도메인 확인 방법
- 최근 웹 사이트는 자신의 웹 서비스 콘텐츠뿐만 아니라 다른 웹 서비스의 다양한 콘텐츠를 호출하여 사용한다.
  + 크롬 브라우저를 사용한다면 [도구 더보기] -> [개발자 도구] -> [Source] 항목을 통해 하나의 웹 페이지에서 어떤 도메인들이 사용되고 있는지 쉽게 파악할 수 있다.
  + 다양한 서비스들이 각 공급자 도메인을 사용하므로 자신이 운영중인 웹 서비스 도메인 성능이 빠르다고 해서 DNS를 조회할 때 웹 성능에 문제가 없다고 판단하기 어렵다.
    + 타사 서비스 도메인 조회 속도가 느려지거나 조회할 수 없는 경우 전반적인 웹 페이지 로딩에 문제가 발생할 수 있다.

#### 웹 성능을 최적화하는 도메인 운용 방법
- 직접 개발한 내부 서비스에 도메인 분할을 하고 싶다면 상위 도메인을 동일하게 해 DNS 질의를 최대한 적게 만드는 것이 권장된다.
  + 도메인 질의를 담당하는 네임 서버에 캐싱된 정보를 재사용할 수 있어 DNS 질의 시간을 단축시킨다.
  + HTTPS 사용을 위한 SSL 인증서를 와일드카드 형식으로 하나만 생성해도 모든 도메인에 사용할 수 있어서 인증서 발급 비용과 수고를 줄일 수 있다.
- HTML의 DNS 프리패치 기능을 사용하면 웹 페이지에 사용된 도메인들의 DNS를 조회하는 시간이 좀 더 빨라진다.
  + DNS의 프리페치: 하나의 웹 페이지에 다수의 도메인 호스트명이 섞여 있을 때 웹 문서 페이지를 여는 시점에 멀티스레드 방식으로 미리 DNS를 조회해 빠르게 IP 주소를 불러오는 기술
    + <LINK> 태그의 지시자 구문에 'dns-prefetch'라는 명령어를 사용
      + `<link rel="dns-prefetch" href="//img.feokorea.com">`

### 브라우저
- 브라우저: HTTP, DNS를 사용해 사용자가 원하는 HTML, 이미지, 오디오, 동영상 등의 웹 콘텐츠를 전달하는 소프트웨어

#### 브라우저의 역사와 특징
- 브라우저는 1990년대 초반 웹이 만들어진 시대에 함께 개발되었다.
- 오디오뿐만 아니라 비디오 형태의 멀티미디어 요소가 늘어나면서 이를 쉽게 웹 페이지에 추가하기 위한 HTML5와 CSS 3.0 버전이 개발되었다. 또한 이를 지원하기 위해 브라우저의 버전도 빠르게 변화했다.
- HTTP가 빠르게 웹 콘텐츠를 전달해도 이를 사용자에게 제공하는 브라우저가 빠르게 작동하지 않으면 전반적인 웹 성능은 느릴 수밖에 없다.
  + 그러므로 웹 성능을 최종 테스트하거나 디버깅하는 작업은 대체로 브라우저를 통해 수행한다.
- 다음은 브라우저를 이용해 웹 사이트의 성능을 확인하는 방법이다.

#### 내비게이션 타이밍 API
- 내비게이션 타이밍 API: 웹 사이트의 성능을 측정하는 데 사용할 수 있는 데이터 제공
- 유용하고 정확한 종단 간 대기 시간 정보를 제공한다.

#### 내비게이션 타이밍 속성
- navigation은 사용자가 어떻게 페이지를 탐색하는가를 조사하는 반면 timing 속성은 탐색과 페이지 로드 이벤트에 대한 데이터를 가지고 있다.
- performance.timing 속성 값들을 통해 각 단계가 언제 완료되었는지, 어떤 특정 항목에서 예상보다 시간이 지체되었는지 확인할 수 있다.

#### 내비게이션 타이밍 속성값 구하기
- navigation 개체를 클릭하여 상세 값들을 살펴보자.
- window.performance.navigation 객체는 페이지 재전송 속성 그리고 앞뒤 이동 버튼이나 URL이 어떤 페이지 로딩을 발생시키는지 확인하는 속성을 저장한다.
  + window.performance.navigation.redirectCount 속성: 페이지 내에서 재전송이 몇 번 발생했는지
  + window.performance.navigation.type 속성: 사용자가 해당 웹 페이지에 어떻게 접속했는지에 관한 정보

# 💭 Insights

### CSS를 HTML 상단에, 자바스크립트를 HTML의 하단에 위치시키기?
- 브라우저에 화면이 뜨는 과정은 다음과 같다.
1. 클라이언트의 요청으로 서버에서 HTML, CSS, Image, JS 순서대로 리소스를 클라이언트에게 전달된다.
2. 브라우저는 구문(HTML, CSS, Image)을 분석하고 렌더링을 실행한다.
3. 마지막으로 JS 엔진(인터프리터)으로 해석하고 실행시킨다.
- 이러한 실행 순서와 더불어 JS의 실행시간이 다른 작업에 비해 느리기 때문에 JS를 상단에 배치하면 화면의 반응성이 낮아지고 사용자에게 불편함을 줄 수 있다.

##### 출처
- https://twosharkbaby.tistory.com/75
