# 6. 캐시 최적화

# **📝 Contents**

## 웹 캐시 동작 원리

- HTTP

- HTTP의 캐시 제어 방식

- 캐시 유효성 체크

- 캐시 콘텐츠 갱신

## 캐시 최적화 방안

- 캐시 가능한 콘텐츠 구분하기

- 올바른 캐시 정책 설정하기

- 캐시 주기 결정하기

- 캐시에 적합한 디렉터리 구조 구성하기

- 캐시 키 올바르게 사용하기

- CDN 사용하기

## 동적 콘텐츠 캐시

- 동적 콘텐츠 캐시

- POST 응답 캐시

## 고급 캐시 전략

- Edge Side Include

- HTML5 로컬 스토리지

# **💭 Insights**

### Expire date VS max-age

- expire date는 종료시각을 설정해 캐시의 만료를 확인하는 것이고, max-age는 유효시간을 설정해 캐시의 만료를 확인한다.
- max-age를 쓰면 캐시된 순간의 시각을 따로 기록하고, 캐시유효성을 판단해야하면 판단시 시각과 캐시된 시각의 차이와 max-age를 비교해서 확인한다.
- expire date는 단순히 현재시간과 비교만 하면되고, max-age는 추가적인 연산과 별도의 캐싱시간 저장이 필요한데, 그걸 상쇄할만큼 서버와 시간차이가 많이 발생하나?
    - 시간동기화 자체가 어렵고, 추가적인 연산과 저장은 성능에 영향을 끼칠 정도가 아니다.
- 그러나 CDN에서는 계층적인 캐시 서버간의 시간차이가 많이 발생하므로 캐시된 시각을 이용해 max-age랑 비교하는 것은 오차가 많아서 ETag등 다른 방법을 사용

### Vary 헤더

- vary 헤더의 사용 목적
    - **요청 조건별 캐싱 제어** : 클라이언트 요청에 따라 다른 리소스를 제공해야 할 때 (Accept-Language )
        - ex) 언어별 콘텐츠 제공
    - **압축 구분** : 콘텐츠 압축 상태(gzip, br 등)에 따라 캐시 ( Accept-Encoding )
    - **사용자 에이전트 구분** : 브라우저, 디바이스별로 다른 리소스를 제공할 때 ( User-Agent )

- 요청별로 나눠서 하는 건 좋은데 왜 쓰지 말라하나?
    - 같은 콘텐츠인데 나눠져서 추가로 저장되는 경우가 생기기 때문
    - 그러면 애초에 설정할 필요가 없는 것을 설정한 것 아닌가?

- User-Agent
    - 이건 접속방법마다 다 따로 캐시를 저장한다
    - 아이폰 사파리, 아이폰크롬, pc 크롬, 등등 다 따로 저장
    - 만약 모바일/pc 정도만 나누고 싶으면 Vary: Accept 를 사용하거나 User-Agent에서 추가적인 세팅을 해줘야한다.
