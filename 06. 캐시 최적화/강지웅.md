# 📝 Contents
## 캐시
- 캐시: 콘텐츠 요청에 빠르게 응답하기 위해 서버와 클라이언트 사이에서 응답 콘텐츠의 사본을 저장하는 공간
- 캐시 서버: 캐시를 유지하고 처리해주는 별도의 서버
  + 기본적으로 브라우저가 사용하는 브라우저 캐시 또는 로컬 캐시
  + 서버에서 성능 향상을 위해 별도로 사용하는 리버스 프록시 형태의 캐시 서버
- 웹 캐시: 리버스 프록시 서버에 캐시 기능을 추가해 리버스 프록시 캐시 서버로 사용
- 시중에는 다양한 웹 캐시들이 있으며 우리가 쉽게 사용할 수 있는 오픈 소스 웹 캐시 서버는 다음과 같은 것들이 있다.
  + Apache Traffic Server, NginX, Vanish Cache


## 웹 캐시 동작 원리
- 웹 캐시는 웹 서버와 웹 브라우저 중간에 존재하면서 최초 원본 콘텐츠 요청을 최종 서버에 보내 응답을 받은 후 그 복사본을 만들어 저장하고 사용자에게 응답한다. 이후 같은 콘텐츠에 대한 요청이 오면 최종 서버에서 원본 서버를 가져오는 대신 아래 그림처럼 복사본을 사용자에게 전달한다. 이렇게 해서 원본 서버로의 트래픽을 줄이고 사용자의 요청에 대한 반응 속도를 빠르게 한다.
- 하지만 모든 웹 콘텐츠를 캐시할 수는 없고 캐시에 저장된 콘텐츠가 변경되면 캐시는 이를 감지해 다시 원본 서버에 원본 콘텐츠를 요청해야한다.
- 캐시 컨트롤 과정은 HTTP에 대한 기본 지식을 먼저 이해해야 한다.

### HTTP
- HTTP: 인터넷에서 데이터를 주고받기 위한 클라이언트/서버 모델을 따르는 프로토콜
  + 클라이언트 서버 모델로 동작한다.
  + 비연결성이며 상태를 유지하지 않은 프로토콜이다.
  + 클라이언트와 서버 간 HTTP 메시지를 주고받으며 통신한다.
  + HTTP 메시지는 헤더와 바디(페이로드) 부분으로 구분되어 전송된다.
    + 헤더: 메시지 전송 및 처리에 필요한 데이터들이 포함
    + 페이로드: 서버가 실제 전송하고자 하는 데이터를 포함
  + 하위 Transport Layer 프로토콜로 TCP를 사용하는데 일반적으로 80포트를 사용한다.

### HTTP의 캐시 제어 방식
- HTTP/1.1부터 명시적으로 캐시를 제어할 수 있는 헤더를 추가했는데 이것이 Cache-Control 헤더
- HTTP/1.1에서 캐시를 제어하는 목적은 크게 두 가지로 정의한다.
  + 원본 서버로의 요청 수를 최소화한다.
  + 완전한 콘텐츠를 응답하지 않아도 된다.
- 이제부터는 HTTP 헤더를 통해 두 가지 목적을 어떻게 달성할 것인지를 살펴보자.

#### Expire
- HTTP/1.0은 Expire 헤더를 사용해 원본 서버 콘텐츠의 유효 기간을 지정하도록 정의한다.
- 이때 원본 서버는 Expire와 Date 헤더를 함께 보내야 하며 Date 헤더는 요청에 대한 응답이 작성된 시점을 표시한다. 캐시는 간단하게 Expire 날짜에서 Date 날짜를 뺴는 것으로 해당 응답의 캐시 유지 시간을 결정할 수 있다.

#### Cache-Control: max-age
- HTTP/1.1에서는 Cache-Control: max-age라는 헤더로 콘텐츠의 캐시 유지 시간을 정의한다.
- 원본 서버는 이 헤더를 사용해 캐시에서 특정 콘텐츠를 얼마나 오래 유지하고 있어야 하는지 명시적으로 설정한다.
- Expire 헤더는 만료 일자를 지정하는 반면 Cache-Control: max-age는 유효 기간을 지정한다.

+) 캐시서버에서는 원본 서버에서 보내 준 Date 값과 응답 시간의 차이를 계산해 age라는 헤더에 담아 요청자에게 반환함으로써 해당 응답이 캐시에 얼마나 오래 머물러 있었는지 알려준다. 또는 이 age 값을 max-age 값과 비교해 캐시된 응답의 만료 여부를 판단할 수도 있다.

#### Cache-Control: s-maxage
- CDN과 같은 공용 캐시 주기를 관리한다.
- s-maxage를 이용하면 사용 중인 모든 CDN의 캐시 주기를 일괄적으로 설정하거나 변경할 수 있다.
- 그러나 표준으로 도입된 지 얼마 되지 않아 CDN 업체가 이 헤더를 지원하는지 먼저 확인해야 한다.

#### ETag
- ETag(Entity Tag) 헤더는 원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호
- 원본 서버의 리소스가 만료되었는지, 캐시된 리소스를 새로 갱신해야하는지 여부를 명확히 판단가능하다.
- ETag 값은 크게 'Strong' ETag와 'Weak' ETag 두 가지로 구분한다.
  + Strong ETag: 모든 리소스에 대해 유일한 값을 가져야한다.
  + Weak ETag: 비교적 간단하게 값을 생성 가능하지만 string보다 신뢰도 낮아짐

#### Cache-Control: public
- 응답이 모든 캐시 서버에 캐시될 수 있고 사용자 제한 없이 모든 사용자에게 응답이 전달될 수 있다.

#### Cache-Control: private
- HTTP 요청에 대한 응답은 요청한 사용자만 캐시할 수 있고 CDN 같은 범용 캐시 서버에서는 캐시할 수 없다.
- 최종 사용자의 브라우저에서만 응답을 자유롭게 캐시할 수 있다.
- 응답에 담긴 개인 정보까지 보호되지는 않으니 주의해야 한다.

#### Cache-Control: no-cache
- 지시자가 요청 헤더에 있으면 브라우저는 원본 서버나 그 중간에 존재하는 캐시 서버들에게 '캐시된 응답을 받지 않겠다'는 메시지를 전달하는 것과 같다.
  + no-cache를 설정하면 캐시 서버는 항상 원본 서버로부터 최신 응답을 받아와야 한다.
  + max-age=0은 캐시된 응답이 여전히 유효하면 캐시에 있는 값을 반환한다.
- 지시자가 HTTP 응답 헤더에 포함되면 원본 서버가 캐시 서버들에게 캐시된 응답을 보내기 전 원본 서버를 항상 확인하도록 강제한다.
  + 캐시 서버가 캐시하지 못하게 하는 것이 아니라 그저 매 요청마다 캐시된 복사본을 원본 서버와 검증하라 강제하는 것이다.
  + max-age=0 설정과 동일하게 동작한다.

#### Cache-Control: no-store
- 서버가 로컬 저장소에 메시지를 저장하지 않도록 지시한다.
- 응답 메시지가 저장소에 저장되는 것 자체를 금지한다. 캐시 데이터의 예기치 않은 유출을 방지하려는 것이다.
- 보안 기능만을 목적으로 사용할 수 없다.

### 캐시 유효성 체크
- 응답의 age가 max-age값을 넘었다면 그 응답은 더 이상 신뢰할 수 없으므로 새 응답을 받아야한다.
- 해당 콘텐츠에 아무런 변화가 없었다면 완전한 응답을 다시 만들어 보내는 것이 의미가 있을까?
  + 캐시에는 아무 변화가 없고 원본 서버는 의미 없는 응답을 만들어 전송하기 위해 서버 자원과 네트워크 대역폭을 낭비한다.
  + 이러한 비효율적인 요청/응답을 방지하고자 HTTP 표준은 조건부 요청이라는 매커니즘을 정의한다.
- 조건부 요청을 보낼 때는 시간을 기반으로 보내는 방법과 콘텐츠를 기반으로 보내는 두 가지 방법을 사용할 수 있다.

#### 시간 기반의 조건부 요청
- 어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠의 최종 변경 시간 중심으로 확인하는 방법
- 날짜 이후 변경 사항이 있다면 원본 서버는 200 코드와 함께 본문이 달린 완전한 응답을, 변경 사항이 없다면 본문 없이 304 코드가 담긴 응답 헤더만을 되돌려줌으로써 불필요한 네트워크 자원 낭비를 막을 수 있다.

#### 콘텐츠 기반의 조건부 요청
- 어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠 고윳값 중심으로 확인하는 방법
  + 고윳값은 원본 서버에서 정의하기 나름이지만 주로 해시값으로 추출한다. 고윳값은 ETag 헤더에 넣어 보낸다.
- 원본 서버는 현재 버전의 ETag 값과 요청 헤더의 ETag 값을 비교해 값이 같다면 캐시 저장본이 현재 버전과 동일하다 판단해 304 응답을 전송한다.

### 캐시 콘텐츠 갱신
- 캐시에 저장된 내용을 갱신하기 위해 다음 두 가지 방법을 사용할 수 있다.

#### 퍼지(purge)
- 저장소를 완전히 지우는 방식으로 대부분의 캐시 서버가 캐시를 모두 지우는 명령어나 API를 제공한다.
- 원본 서버에 충분한 자원이 있는지 확인하는 등 주의를 기울여야 한다.
- CDN에 많은 트래픽을 의존하며 원본 서버 용량을 최소로 유지하고 있다면 많은 양의 콘텐츠를 퍼지하는 것은 피하고, 단계적으로 나누어 퍼지하거나 다음에 설명할 무효화 방안을 사용하는 것을 권장한다.

#### 무효화(invalidate)
- 캐시 저장소를 완전히 지우기보다 조건부 요청을 통해 캐시된 리소스들 중 변경이 있었던 리소스들만 새로 갱신하는 방법
- Cache-Control 헤더를 사용해 캐시 서버의 내용을 강제로 무효화할 수 있다.
```
Cache-Control: max-age=0, must-revalidate
```

## 캐시 최적화 방안
- 캐시 사용을 최대화할 수 있는 3가지 기본 원리는 다음과 같다.
  + 최대한 많이 캐시하라
  + 최대한 오래 캐시하라
  + 최대한 가까이 캐시하라

### 캐시 가능한 콘텐츠 구분하기
- WebPageTest를 통해 웹 페이지의 구성과 얼마나 많은 파일들을 캐시할 수 있는지 확인할 수 있다.
- 웹 사이트를 구성하는 콘텐츠는 크게 정적인 콘텐츠와 동적인 콘텐츠로 분류할 수 있다.
  + 정적 콘텐츠: URL을 호출할 때마다 변함없이 같은 응답을 주는 콘텐츠
  + 동적 콘텐츠: 사용자가 요청할 때마다 서버에 의해 다시 생성, 응답되는 콘텐츠
- 캐시하기 어려운 콘텐츠: 개인화된 콘텐츠, API 호출이나 Ajax 요청에 대한 콘텐츠, Beacon 전달 또는 쿠키 설정을 위한 호출 등

### 올바른 캐시 정책 설정하기
- 우선 웹사이트를 구성하는 리소스들을 같은 타입끼리 그룹화하고 아래와 같은 순서를 참고해 하위 그룹을 나누고 캐시 정책을 정한다.
  + 먼저 캐시할 수 있는 콘텐츠인지 판단한다.
  + 캐시할 수 있는 콘텐츠들은 매번 원본 서버에 변경 사항을 확인해야 하는지 판단한다.
  + 캐시할 콘텐츠들의 성격을 판단한다.
  + 마지막으로 캐시 주기를 설정하고 max-age를 추가한다.

### 캐시 주기 결정하기
- 콘텐츠의 캐시 주기는 어떻게 결정해야 할까
  + 캐시 주기는 콘텐츠 타입별로 다르게 설정할 수 있다.
  + 만약 링크 변경 없이 이미지 내용만 바꿔야 한다면 캐시 무효화 방식으로 해당 이미지만 캐시에 업데이트한다.
  + 모든 정적 파일에 대해 캐시 주기를 길게 설정하고 수동으로 캐시 주기를 관리하는 방법도 있다.
- 가능한 더 오래 캐시할 수 있도록 캐시 주기를 조절할 것을 권장한다.

### 캐시에 적합한 디렉터리 구조 구성하기
- 캐시에 적합한 디렉터리 구조를 구성하려면
  + 첫 번째로 캐시할 수 있는 콘텐츠들을 별도의 폴더에 분류해 관리한다.
  + 두 번째로 캐시 주기별로 나누어 구성한다.
  + 세 번째로 동일한 파일을 여러 곳에 분산시키지 않아야 한다.

### 캐시 키 올바르게 사용하기
- 캐시 키: 캐시 서버가 원본의 복사본을 저장하고 빠르게 조화하기 위해 사용하는 키 값
- 일반적으로 웹 캐시는 클라이언트가 요청하는 URL을 캐시 키로 사용한다.
- 일반적인 캐시 키 구성: 호스트/패스?쿼리 스트링

#### 캐시 오염과 캐시 충돌
- 캐시 오염: 원본 서버에 하나의 원본 파일만 존재하는데 캐시에 복사본이 여러 개 존재하는 것
- 캐시 충돌: 요청 URL이 하나인데 브라우저 환경에 따라 서버에서 제공하는 응답이 달라져 결국 최초 요청한 브라우저의 응답만 캐시되는 것

#### 캐시 오염 제거
- URL에 붙은 특정 쿼리 스트링 값이 달라지더라도 응답이 항상 같다면 캐시 키에서 쿼리 스트링을 무시하도록 설정해야한다.
  + 대부분 캐시 서버에는 특정 쿼리 스트링을 무시할 수 있는 설정이 있다. 이를 통해 리소스 낭비를 막을 수 있다.
- 쿼리 스트링의 순서를 동일하게 정렬한다.
  + 쿼리 스트링을 사용할 때는 오름차순이나 내림차순으로 항상 동일하게 순서를 정렬해 호출하도록 설정해야한다.
- Vary 헤더를 바르게 사용해야 한다.
  + Vary 헤더는 서버의 응답이 상황에 따라 달라니는 것을 의미한다. 꼭 필요한 경우가 아니라면 Vary 헤더를 사용하지 않거나 Cache-Control: private을 사용해 중간 캐시 서버에는 캐시하지 않도록 하는 것을 추천한다.

#### 캐시 충돌 방지
- 일반적으로 홈페이지는 로그인 전후로 같은 URL을 사용하므로 동적 페이지에 대한 특별한 캐시 설정을 하지 않으면 캐시 충돌 현상이 나타난다. 이 현상을 피하려면 기본적으로 동적 페이지에는 캐시를 적용하지 않아야 한다.
- 보통 홈페이지의 첫 HTML은 캐시하지 않는다.

### CDN 사용하기
- CDN 서비스를 사용하면 세계 여러 지역 데이터 센터들에 리버스 프록시 캐시 서버를 두고 필요한 정적 콘텐츠들을 저장해놓을 수 있다.
- 또한 사용자가 관련 콘텐츠를 요청 할 때 사용자가 가장 가까운 캐시 서버에서 해당 콘텐츠가 서비스 되므로 시간 지연 없이 빠르게 웹 페이지를 로딩할 수 있다.

## 동적 콘텐츠 캐시
- 가능한 많은 콘텐츠를 캐시하는 것이 페이지 성능을 향상 시키는 손쉬운 방법 중 하나
- 웹 콘텐츠들을 특성에 따라 분류
  + 정적 콘텐츠와 동적 콘텐츠
  + 익명 콘텐츠와 개인화 콘텐츠
  + 시간에 민감한 콘텐츠와 시간에 둔감한 콘텐츠

### 동적 콘텐츠 캐시
- 동적 콘텐츠를 사용자에게 전달하기 위해 원본 서버는 두 가지 방법을 사용한다.
  + 동적 정보를 쿠키에 넣어 보낸다.
  + Ajax 요청으로 관련 정보를 동적으로 받아 온다.
- 요청 쿠기, 헤더 혹은 쿼리 스트링에 동적 콘텐츠에 대한 정보가 있으면 이 정보들을 캐시 키에 추가함으로써 동적 콘텐츠를 캐시할 수 있다. 사용자 로그인 페이지는 로그인 정보가 쿠키에 있는 경우와 없는 경우로 그룹화하고 쿠키가 없을 때만 캐시한다.
  + 이때 첫 번째로 보안에 주의해야 한다.
  + 두 번째로 캐시 서버 용량에 유의해야 한다.
- Ajax 요청을 통해 전달되는 동적 콘텐츠를 캐시하는 방법은 간단하다. 시간에 민감한지 여부가 관건이다.
  + 따라서 캐시하고자 하는 콘텐츠의 시간에 따른 민감도를 미리 결정하고 이에 맞게 캐시 주기를 설정하여, 이 시간이 만료된 경우에만 캐시 서버가 원본 서버에서 갱신된 결과를 받아오도록 해야한다.
- 콘텐츠 캐시 가능 여부 판단 시 주의할 점
  + 캐시는 통상 HTTP GET 방식에서 동작하므로 Ajax 요청에 대한 응답을 캐시하고자 하면 HTTP POST 방식보다 GET 방식을 사용한다.
  + 캐시 주기로 0 TTL을 사용하려면 서버에서 해당 콘텐츠에 대한 If-Modified-Since(IMS) 요청을 지원해야 한다.

### POST 응답 캐시
- POST 메소드는 HTTP 페이로드 메시지에 쿼리 스트링을 포함시켜 보낼 때 사용한다. 데이터 크기에 제한이 없고 타인이 브라우저를 통해 쉽게 볼 수 없어 보안 측면에서도 상대적으로 안전하다.
- GET 메소드는 요청 URL에 붙여 보낼 수 있는 쿼리 스트링 길이에 제한이 있다. 요청 URL이 타인에게 쉽게 노출될 수 있으므로 개인 정보들을 GET 메소드를 이용해 서버에 보내는 것은 적합하지 않다.
- POST 메소드에 의한 응답은 POST 요청 본문에 포함된 매개 변수들에 의해 결정된다.
- POST 요청/응답을 캐시하려면 다음과 같은 조건을 만족해야 한다.
  + 매개 변숫값에 항상 같은 응답이 오는 경우
  + 개인 정보가 포함되지 않는 경우
  + 요청 사이즈가 크지 않은 경우

## 고급 캐시 전략
### Edge Side Include
- 첫 번째 HTML이 서버에서 브라우저까지 도달하는 시간을 Time To First Byte라고 하며 웹 사이트 성능을 측정하는 매우 중요한 지표이다. 그럼에도 불구하고 동적 콘텐츠때문에 많은 웹 관리자들이 이 첫 HTML을 캐시하지 않는다.
- ESI(Edge Side Include): 인터넷 에지에서 웹 페이지 조각을 동적으로 조합, 조립, 전달할 수 있도록 이에 대한 문법과 용도 등을 정의한 XML 기반 표준 마크업 언어
- ESI에서 사용되는 대표적인 태그는 다음과 같다.
  ```
  + <include>: 현재 페이지의 현재 위치에 포함시키고자 하는 리소스를 명시한다.
  + <choose> / <when> / <otherwise>
  + <try> / <attempt> / <except>
  + <remove>
  ```
- ESI는 다음과 같이 다양한 경우에 사용할 수 있다.
  + 페이지 내에 일부 동적인 부분이 존재할 때 이 부분만 별도 페이지로 만들어 본래 페이지에 동적으로 삽입할 수 있다.
    + 서버를 주기적으로 호출할 수 없어 실시간 주식 시세처럼 주기적 업데이트가 필요한 용도에는 적합하지 않다.
  + 서로 다른 성격의 콘텐츠를 각각의 캐시 정책을 사용해 캐시하고자 할 때 유용하다.
  + 사용자 등급에 따라 콘텐츠를 제한하고자 할 때 유용하다.
  + 웹 어플리케이션 개발에 협업이 필요할 때 유용하다.
    + 공통으로 사용할 스타일시트나 자바스크립트만 이미 협의하면 개발팀들은 맡은 페이지만 독립적으로 개발 및 유지보수하고 ESI를 사용해 최종 조립하면 된다.

### HTML5 로컬 스토리지
- HTML5의 주요 기능
  + WeSemantic Tag
  + Web Storage
  + Multimedia
  + Graphics
  + Device Access
  + Performance
  + Connectivity
  + CSS3
- HTML5 웹 스토리지의 가장 중요한 역할은 쿠키를 대체하는 것이다. 일반적으로 사용자 정보는 쿠키를 통해 저장되고 매번 네트워크를 통해 전달되어 보안에 취약하다.
- 쿠키 대신 웹 스토리지를 사용할 경우 데이터가 한 번 저장되면 세션 주기 내에 또는 만료 없이 로컬 스토리지에서 얼마든 불러 쓸 수 있어 보안상 더 안전하다.


# 💭 Insights

### 캐시 VS 쿠키 VS 웹 스토리지
![image](https://github.com/user-attachments/assets/b7fc45ad-cb9e-499c-876c-fabde8ba2dc3)

- 캐시: 웹 페이지 요소(e.g.img,css,js등 리소스파일)를 저장하기 위한 임시 저장소 for 빠른 웹페이지 랜더링
- 쿠키: 사용자가 웹 사이트를 방문할 때, 그 사이트에서 생성되어 클라이언트 측에 저장되는 작은 데이터 파일로 주로 사용자의 인증 상태 유지, 사용자 선호도 저장 등에 사용된다.(정보 저장소 for 사용자인증)
- 웹스토리지: HTML5에서 추가된 클라이언트 측 데이터 저장소로 쿠키와 달리 웹 스토리지는 클라이언트 측에서만 사용되며, 서버로 전송되지 않는다. 이러한 특징 때문에 웹 스토리지는 쿠키와 달리 사용자 데이터 보안을 보장할 수 있다. 웹 스토리지는 사용자 개인 데이터의 저장과 관리에 매우 유용하다.
- 출처: https://msj725.tistory.com/158, https://sowon-dev.github.io/2022/11/21/221121JS-webstorage/
