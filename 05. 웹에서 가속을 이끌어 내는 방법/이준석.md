# **📝 Contents**

## 웹 브라우저의 동작

- 웹 동작 순서
    1. 웹사이트 주소를 입력 → 서버로부터 웹페이지를 다운로드
    2. 도메인 서버와 통신 → 접속하려는 호스트의 IP를 찾음
    3. 서버와 TCP 연결 → HTTPS라면 암호화된 연결 협의 단계 추가
    4. 서버로부터 리소스를 다운로드 → HTML, CSS, JavaScript, 이미지 등을 순차적 다운
    5. 렌더링 → 화면에 웹 콘텐츠 그림

- 브라우저 아키텍처 구성
    - 유저 인터페이스(UI) : 사용자가 브라우저와 상호작용함. 주소창, 북마크, 뒤로가기 버튼 등 제공
    - 브라우저 엔진 : 유저 인터페이스와 렌더링 엔진 사이에서 상태를 조회하고 작업을 제어
    - 렌더링 엔진 : HTML, CSS를 분석해 화면에 웹 콘텐츠를 그림
    - 네트워킹 : HTTP 요청과 응답을 처리
    - UI 백엔드 : UI 요소(버튼, 폼 등) 그리는 데 사용
    - 자바스크립트 해석기 : JavaScript 코드 실행을 담당
    - 데이터 저장소 : 쿠키, 로컬 스토리지 등 데이터를 보관

- 렌더링 과정

<img width="785" alt="스크린샷 2024-12-16 오후 4 48 55" src="https://github.com/user-attachments/assets/710fc1b6-147b-462a-b47e-f259aab64aab" />

## 브라우저 렌더링 최적화하기

- DOM 최적화
    - HTML 문법 오류를 줄이고 간소화
    - 태그 중첩을 피함 → 자바스크립트로 스타일 변경 시 불필요한 레이아웃 재계산을 방지

- CSS와 JavaScript 배치
    - CSS를 위쪽에 배치함 → CSSOM이 빠르게 생성
    - JavaScript를 아래쪽에 배치함 → DOM과 CSSOM이 생성된 후 실행
    - async와 defer를 활용함 → 렌더링을 방해하지 않도록 JavaScript를 비동기로 처리

- CSS 최적화
    - 필요하지 않은 CSS는 분리
    - 미디어 쿼리를 사용함 → 조건에 맞지 않는 CSS는 다운로드하지 않음.

- 이미지 최적화
    - background-image를 사용해 불필요한 다운로드를 줄임.
    - JavaScript를 이용한 지연 로딩(Lazy Loading)을 적용.

## 도메인 분할 기법 이용하기

- 

## 사용자 경험 개선하기

- 

# **💭 Insights**

### speed index

- 웹페이지가 얼마나 빨리 시각적으로 로드되는지를 측정하는 지표로, **사용자가 콘텐츠를 처음 인식할 수 있을 때까지의 시각적 진행도**를 수치화
- 근데 눈에 보이는걸 어떻게 측정하나?

1. 비디오 캡처

- 브라우저의 렌더링 화면을 비디오로 캡처
- 실제 사용자가 보는 화면과 동일하게 캡처하여 로딩 과정을 기록

2. 프레임 분석

- 캡처한 비디오를 프레임 단위로 나눔
- 각 프레임에서 페이지가 렌더링된 시각적 진행도를 계산
- 프레임의 픽셀 데이터를 기반으로 완전히 로드된 화면과 비교하여 얼마나 많은 콘텐츠가 로드되었는지 평가

3. 시각적 진행도 계산

- 각 프레임에서 렌더링된 픽셀 비율(%)을 계산해 시각적 진행도를 측정

- 근데 녹화를 하면 그만큼 리소스를 잡아먹어서 느려지거나 하지 않나?

- 그래서 다음 방식을 사용
    - 브라우저의 내장 API 활용
        - 실제 화면을 녹화하지 않고, 브라우저에서 직접 프레임 데이터를 캡처합니다.
            
            ex) Google Lighthouse는 Chrome의 DevTools 프로토콜을 사용해 브라우저 렌더링 상태를 추적
            
        - 브라우저에서 직접 데이터를 가져오기 때문에 추가적인 성능 오버헤드가 적음
    - 프레임 캡처
        - 실제 녹화가 아니라, 특정 시점마다 화면의 스냅샷을 캡처
        - 스냅샷은 성능에 영향을 미치지 않도록 브라우저의 렌더링 파이프라인에서 효율적으로 처리
    - 로컬 환경이 아닌 별도 서버에서 측정
        - Speed Index는 종종 WebPageTest 같은 외부 서비스에서 수행
        - 가상 환경에서 테스트를 실행하므로 로컬 장치 성능에 영향을 미치지 않음

- 브라우저의 내부 데이터 수집(DevTools 프로토콜, 프레임 캡처)은 매우 가벼운 작업이어서 일반적인 웹 로딩 속도에 거의 영향을 미치지 않음
- 그러나, 비디오 캡처를 사용하거나 리소스가 제한된 환경(낮은 성능의 장치)에서 실행하면 약간의 오버헤드가 발생할 수 있음
- 이러한 경우 Speed Index 계산에 사용되는 추가 시간을 보정하거나, 결과에서 이를 무시하는 방식으로 처리



### **Cumulative Layout Shift : 누적 레이아웃 이동**

<img width="736" alt="스크린샷 2024-12-16 오후 4 58 32" src="https://github.com/user-attachments/assets/e9cd517c-6a1a-4232-88bc-fea844eef286" />

- 웹페이지 로딩 중 시각적인 요소들이 예기치 않게 이동하는 정도를 측정하는 웹 성능 지표
- 계산 방법 : CLS는 레이아웃 이동 거리와 화면의 영향 범위를 기반으로 계산
    1. 레이아웃 이동 거리(Fraction of Impact)
        - 요소가 화면에서 이전 위치에서 이동한 비율을 계산.
        - 화면 높이를 기준으로 이동 거리를 비율로 나타냄.
    2. 영향받은 화면 영역(Fraction of Viewport)
        - 이동한 요소가 차지한 화면 영역의 비율을 계산.

- CLS가 발생하는 주요 원인
    - 이미지와 동영상 크기 미지정 : 이미지나 동영상의 width와 height를 명시하지 않으면 브라우저가 공간을 예약하지 못해 콘텐츠가 이동할 수 있음.
    - 동적 콘텐츠 삽입 : 광고, 팝업, 배너 등이 로딩 중에 추가되면 기존 콘텐츠 위치가 변경
    - 웹폰트 로딩 지연 : 폰트 로딩 전 기본 폰트를 사용했다가 로딩 후 다른 크기의 폰트로 변경되면 텍스트 위치가 바뀜.
    - 애니메이션과 전환 효과 : CSS 애니메이션이나 동작이 레이아웃을 변경시키는 경우.
