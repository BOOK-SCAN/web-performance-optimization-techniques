# 📝 Contents

## 웹브라우저 현황 알아보기

- 웹 페이지를 경량화하고 요청 수를 줄여도 HTML을 화면에 그리는 것은 결국 웹 브라우저. 따라서 브라우저가 페이지를 화면에 렌더링하는 방식을 이해하고 이를 최적화하는 것이 프론트엔드 최적화의 핵심
- 구글의 크롬은 데스크톱 브라우저에서 69%, 모바일에서는 64%의 점유율을 차지할만큼 전 세계에서 가장 많이 사용된다.
- 브라우저별로 지원하는 이미지 타입이 서로 다르므로 점유율이 높은 브라우저에 대한 이미지를 별도로 준비하는 것이 효율적
- 많은 브라우저가 존재하고 저마다의 특징을 가지고 작동하지만, 웹페이지를 전송하고 렌더링하는 방식에는 큰 차이가 없이 표준 방식으로 작성된 HTML을 해석하고 이에 맞도록 객체를 생성하며 화면 크기에 맞추어 원하는 그림을 그린다.


## 웹 브라우저 동작 이해하기

- 브라우저가 웹 사이트의 주소를 이용해 서버로부터 웹 페이지를 다운로드하기까지 흐름은 다음과 같다.
  1. 브라우저는 가장 먼저 도메인 서버와 통신하여 접속하려는 호스트의 IP를 찾는다.
  2. 해당 아이피를 가진 서버와 통신을 시도해 TCP 연결을 맺는다.
  3. HTTPS에선 암호화된 연결을 생성하려는 협의 단계가 더 추가된다. 이후 연결이 맺어지면 브라우저는 서버로부터 필요한 리소스들을 다운로드해 이를 화면에 표현한다.
      + 브라우저가 리소스를 다운로드할 때는 먼저 방문 페이지의 HTML을 서버에 요청해 다운로드하고 구문을 분석하면서 태그에 참조된 하위 리소스들을 차례로 다운로드한다.
      + 브라우저는 리소스들을 다운로드하며 동시에 개발자가 원하는 대로 화면에 페이지를 그리는 작업을 수행한다.
- 렌더링 경로: 앞서 설명한 화면을 그리는 일련의 작업 절차


### 브라우저 아키텍처
- 브라우저는 크게 7개의 컴포넌트로 나눌 수 있다.
  + 유저 인터페이스, 브라우저 엔진, 렌더링 엔진, 네트워킹, UI 백엔드, 자바스크립트 해석기, 데이터 저장소
  + 모든 컴포넌트들이 유기적으로 동작
- 실제로 HTML을 처리해 화면에 렌더링하는 컴포넌트는 **렌더링 엔진**

### 중요 렌더링 경로
- 렌더링 엔진은 선후 관계가 비교적 명확하므로 단일 스레드에 의해 수행된다.
- 아래 그림은 브라우저의 중요 렌더링 경로를 나타낸다.

<img src="https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/crp.png" width="600" height="200"/>

#### 1. DOM 트리 생성
- 브라우저는 가장 먼저 다운로드한 HTML의 구문을 분석해 태그를 하나하나 해석하여 DOM이라는 객체 모델로 변환한다.
- DOM(Documents Object Model): 객체 지향적 프로그램 언어들로 HTML이나 XML 형태의 마크업 문서들을 손쉽게 프로그래밍하기 위해 표준으로 규정한 프로그램 인터페이스
- DOM은 객체 속성과 메소드, 이벤트 등을 정의한다.
- 브라우저 구문 분석기는 **위에서부터 순차적으로 HTML을 분석하며** 부모 노드와 자식 노드와의 관계를 파악해 DOM 트리를 구성한다.

#### 2. CSSOM 트리 생성
- CSSOM(CSS Object Model): CSS를 처리하기 위한 트리 구조의 프로그래밍 인터페이스
- HTML과 다르게 CSS는 구문 분석에는 엄격한 구문 검사가 적용된다. 사용하는 구문 분석기와 동작 스레드도 다르다.

#### 3. 렌더 트리 생성
- DOM 트리와 CSSOM 트리 구문 분석이 완료되면 브라우저는 두 개의 트리를 병합하여 렌더 트리를 생성한다.

#### 4. 레이아웃
- 렌더 트리 노드들의 위치 정보가 계산되는 단계
- 렌더 객체는 사각형 영역을 표시하므로 **브라우저 창의 맨 왼쪽 위에서 시작하여 아래, 오른쪽으로 이동하며** 각 사각형 영역의 너비와 높이를 계산한다.

#### 5. 페인트
- 렌더 트리 정보를 바탕으로 브라우저 창에 표현하는 단계
- 이미 렌더링을 위한 정보가 모두 준비되었으므로 GPU를 이용해 그리기만 하면 된다.


## 브라우저 렌더링 최적화하기

### DOM 최적화하기
- HTML을 DOM으로 전환하는 과정은 구문 분석이 관대하다는 점에서 XML과 다르다.
  + XML은 DTD 또는 XML 스키마를 이용해 정의된 구문을 엄격하게 따라야 한다.
  + 반면 HTML은 구문 체크에 관대하므로 작성 시 잘못된 습관이나 실수에 의해 문법 오류가 발생해도 브라우저에는 정상적으로 표현되는 경우가 많다.
- 결국 HTML의 구문 오류를 최소화하고 간소화하는 것이 웹 사이트 성능을 향상시키는 기본적이고도 간단한 방법
- 과도하게 HTML 태그를 중첩 사용하는 행위도 피해야 한다.
  + 일반적으로 중첩된 태그들이 15단계를 넘지 않도록 HTML을 작성하는 것을 권장한다.
- DOM Monster: 전체 노드 개수, 중첩 노드 개수, 사용된 iframe 태그 수에 대한 경고와 함께 기타 최적화 팁을 제시해주는 무료 도구

### 자바 스크립트와 CSS 배치하기
- HTML과 CSS에서 사용하는 구문 분석 알고리즘과 스레드는 다르기 때문에 CSS 구문 분석을 위해 HTML 구문 분석을 처리하는 스레드가 차단 당하진 않지만 여기서 자바스크립트가 중요한 역할을 한다.
  + 자바스크립트는 이미 생성한 DOM과 CSSOM을 언제든 변경시킬 수 있기 때문
- 렌더링에 있어 DOM보다는 자바스크립트가, 자바스크립트보다는 CSS가 더 높은 우선순위를 가진다.
- **CSS와 자바스크립트의 렌더링 방해를 피하려면 CSS를 최대한 소스 위쪽에 배치하여 CSSOM이 가능한 빨리 생성되도록 한다. 자바스크립트는 최대한 HTML 아래쪽에 배치하여 DOM과 CSSOM이 모두 생성된 이후에 수행될 수 있도록 하는 것이 가장 효과적이다.**

### 자바스크립트 최적화하기
- 자바스크립트를 HTML 아래쪽에 배치하는 것만으로는 충분하지 않다.
- 자바스크립트가 전체 페이지 로딩 시간에 영향을 주는 것을 막으려면 자바스크립트 수행이 렌더링 스레드를 방해하지 않도록 별도 스레드로 자바스크립트를 수행시켜야 한다.
  + async 속성: HTML 구문 분석과 동시에 자바 스크립트를 다운로드하고 수행되도록 한다.
  + defer 속성: 구문 분석 중에 별도의 스레드로 자바스크립트를 다운로드하고 구문 분석이 끝난 이후에 수행되도록 한다.
  + async 속성은 지연 수행 시 스크립트 간 선후 관계를 따지지 않지만 defer 속성은 스크립트가 호출되 순서에 따라 차례로 수행된다.
- 주의할 점은 모든 자바스크립트가 비동기나 지연 처리의 대상 될 수 없다는 것이다.
  + 페이지에 사용되는 자바스크립트 중 초기 렌더링에 꼭 필요하지는 않은 그룹에 async, defer 속성을 적용
  + 브라우저가 페이지 로딩을 명시적으로 끝낸 후 나머지 스크립트를 수행

### CSS 최적화하기
- CSS는 렌더링 순위가 가장 높으년서 동시에 렌더링을 가장 방해하는 리소스
- CSS는 필요한 정보만 빠르게 다운로드하고 실행해야 브라우저 렌더링을 가속시킬 수 있다.
  + CSS를 적절히 분리하여 필요한 페이지에 필요한 CSS 파일만 포함할 것
    + 미디어 쿼리를 활용
  + 첫 화면에 사용될 CSS 파일과 숨겨진 화면에 사용될 CSS 파일을 분히해 후자의 CSS는 지연 수행할 것

### 이미지 로딩 최적화하기
- 웹 최적화에 있어 이미지 압축은 필수일 정도로 이미지 로딩 최적화는 다른 방법들에 비해 효율적이다.
- 화면 렌더링에 필요하지 않은 이미지를 다운로드하지 않으려면?
  - 그 이미지가 웹 사이트의 주요 이미지가 아니라면 CSS의 background-image 속성을 사용
  - 자바스크립트를 이용한 지연 로딩 방식을 적용
    + 사용자 경험 개선에는 항상 도움이 되지 않을 수 있으므로 첫 화면에 등장하지 않거나 숨겨진 이미지들을 다운로드하는 데만 사용할 것
  - Progressive JPG 활용
    + Progressive JPG: 고품질 이미지를 한 번에 전송하지 않고 분할 전송하는 방식. 초기에는 저품질 이미지가 보이지만 점차 원래 품질을 회복함


## 도메인 분할 기법 이용하기

- 도메인 분할 기법: 여러 도메인을 소유한 경우 웹 콘텐츠를 병렬적으로 동시에 다운로드할 수 있도록 하는 방법
  + 브라우저는 HTTP/1.1 프로토콜 하에서 동일 도메인에 순차적 다운로드 방식 사용
- 도메인 분할 기법을 이용하면 사이트 전체의 쿠키 사이즈를 축소 가능
- 기술적으로 어렵진 않으나, 도메인을 몇 개로 운용하는 것이 최적인지 결정하는 데는 좀 더 면밀한 계획과 테스트가 필요하다. 너무 많은 도메인을 추가하면 오히려 브라우저의 성능을 저하시킬 수 있다.
- 간단한 계산을 이용해 기준이 되는 도메인 숫자를 정하고 다양한 테스트를 통해 적정한 도메인 숫자를 결정하는 것이 권장된다.
- 사용할 도메인 개수가 정해지면 그 수에 맞도록 리소스들을 균등 분할하는 것이 권장된다.
  + 리소스들을 분류하는 방법은 두 가지가 있다.
    + 리소스 성격에 따라 분류
    + 배포 시점에 동적으로 도메인명을 결정: 특정 리소스에 항상 같은 도메인이 배정되도록 해야만 캐시 적중률이 높아진다. 방안으로 해시 방식이 있다.
      + 해시 방식: 해시 함수를 사용해 파일명을 숫자 배열로 변경하고 숫자에 따라 도메인을 결정하는 방식

### 도메인 분할 기법과 HTTP/2
- 도메인 분할 기법은 HTTP/1.1의 Head Of Line Blocking 현상 문제로 고안되었으나, HTTP/2의 멀티플렉싱 기술로 해결되어 도메인 분할 기법을 사용할 이유도 자연스럽게 사라졌다.
- 최근 사용되는 브라우저들은 HTTP/2의 기능을 저해하지 않으면서 다중 도메인을 사용할 수 있는 방안으로 TCP 연결을 병합하는 방식을 제공한다.
  + TCP 연결 병합: 브라우저가 첫 번째 도메인과 맺은 TCP 연결을 나머지 도메인에 재사용하는 방식
- TCP 연결 병합 기술이 적용되기 위해 다음 몇 가지 고려할 사항이 있다.
  + 브라우저가 DNS를 확인할 때 각 도메인은 모두 동일한 IP 주소를 반환해야 한다.
  + 동일한 인증서를 사용해야 한다. (와일드 카드 인증서나 SAN 인증서 사용)

## 사용자 경험 개선하기

- 브라우저의 성능 지표만 향상시킨다고 해서 실제 사용자가 느끼는 성능이 향상되는 것은 아니다. 그러므로 이를 위한 다른 방식의 측정 방법 및 개선 방안이 요구된다.

### 사용자 경험 지표 바로 알기
- 사용자 중심의 지표에는 다음과 같은 것이 있다.
  + WebPageTest의 Speed Index
  + 구글 크롬 팀의 First Contentful Paint, Largest Contentful Paint, Time to Interactive 등

### 사용자 요청에 빠르게 반응하기
- 사용자가 해당 웹 사이트 URL을 클릭했을 때 적어도 1초 안에 반응하고 2초 안에 페이지 로딩이 완료되어야 사용자의 이탈을 방지할 수 있다.
- 브라우저가 렌더링을 빠르게 시작하게 하려면 다음과 같은 최적화 기법들을 고려할 수 있다.
  + CSS와 자바스크립트 파일들의 크기를 줄인다: 크롬 브라우저의 Coverage 모듈을 활용
  + CSS와 자바스크립트들을 중요 리소스와 그렇지 않은 리소스로 분류
  + 위레서 분류된 중요 리소스들은 가능한 빠르게 로딩: preload나 HTTP/2 서버 푸시 활용
  + 중요하지 않은 리소스들은 나중에 로딩: async나 defer 속성 사용 또는 onLoad 이벤트 이후에 수행하도록 지연

### 사용자 시선 붙잡기
- 브라우저가 화면 렌더링을 시작했더라도 2초 안에 의미 있는 콘텐츠가 표현되지 않으면 사용자가 이탈할 가능성이 높아진다. 시선을 붙잡으려면 Hero 이미지가 가능한 빠르게 화면에 로딩되어야 한다.
- 그러나 Hero 이미지는 여러 이유로 지연 로딩될 가능성이 많기 때문에 다음과 같은 규칙을 따르면 Hero 이미지를 일찍 로딩하여 사용자 경험을 향상시킬 수 있다.
  1. HTML의 <img> 태그나 <picture> 태그를 사용하여 직접 다운로드하고 지연 로딩을 적용하지 않는다.
  2. CSS background-image 속성에 Hero 이미지를 사용하지 않는다.
  3. CSS 배경 이미지로 Hero 이미지를 꼭 사용해야 한다면 리소스 힌트인 preloa를 사용해 일찍 다운 받는다.
- 메인 텍스트도 의미 있는 콘텐츠를 구성하므로 경향화 후 preload를 사용해 일찍 다운로드하는 것이 권장된다. 

### 사용자 상호 작용 방해하지 않기


# 💭 Insights

### 프로그램 인터페이스?
- 프로그램 인터페이스: 컴퓨터나 프로그램 간의 연결을 의미하는 용어
- DOM은 문서 전체를 객체로 변환하여 간단하게 접근하고 조작할 수 있게 해주는 응용 프로그램 개발 인터페이스(API)
- DOM이란 HTML 문서를 파싱하고 문서의 요소들을 객체 형태로 변환한 것입니다. · DOM tree에 DOM API를 통해 접근하여 DOM을 동적으로 바꿀 수 있습니다.

=> 뭐가 제대로 된 말?

### DTD? XML 스키마?
- DTD(Document Type Definition)이란, 말 그대로 문서 타입 정의이다.
- 문서타입을 정의함으로써 적절한 요소, 속성을 사용하게한다.
- XML 문서의 구조가 유효한지 확인한다.
```
<!DOCTYPE 루트요소 DTD식별자 [ 선언1 선언2 ... ]>
```
- 위와 같은 형태로 쓰인다.
- XML 스키마란, XML 문서의 모든 속성과 요소에 대한 규칙을 정의한다.
- DTD와 큰 차이로는 네임스페이스를 지원한다.
```
<?xml
```
- 위와 같은 형태로 쓰인다.

