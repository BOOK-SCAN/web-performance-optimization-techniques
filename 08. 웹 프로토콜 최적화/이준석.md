# 8.  웹 프로토콜 최적화

# **📝 Contents**

## HTTP의 발전

- 초기 HTTP(HTTP/0.9)는 GET 메소드만 있어 클라이언트 정보를 서버로 전달은 불가능
- 받은 콘텐츠도 텍스트만 읽기 가능
- HTTP/1.0부터 헤더를 통한 클라이언트-서버 간 이미지, 동영상 등 다양한 정보 전달가능
- POST 메소드가 추가되어 서버로 정보 전달 가능
- content- encoding 헤더를 통해 클라이언트 서버 간의 압축 정보를 공유해 압축하여 정보 전달

## HTTP/1.1

- HTTP의 첫 공식 버전
- PUT, DELETE 메소드가 추가되어 웹 서버로 업로드, 삭제가 가능해짐
- 파이프라이닝 : 브라우저가 웹 서버에 여러개의 콘텐츠 요청시 하나의 TCP 연결 내에서 이전 요청에 대한 응답을 완전히 다 안받아도 다음 요청에 대한 처리를 시작해 시간을 줄이는 방식
- 문제점
    - HOL(Head-Of-Line blocking) : 서버가 하나의 응답을 지연하면 그 뒤의 다른 응답도 지연되는 문제

## HTTP/2

- 헤더와 페이로드를 기존의 텍스트 방식에서 이진 형태의 프레임으로 추상화해 경량화
- HTTP/1.1에서 몇가지 프로토콜 최적화 기능이 추가
- HTTP의 HOL문제는 해결했지만 상위 프로토콜인 TCP에서의 HOL은 해결하지 못함

- **이진 프레임**
    - 기존의 텍스트로 이루어진 메시지 단위의 요청/응답이 아닌 프레임,스트림이라는 단위를 추가
    - 프레임 : 데이터 / 헤더 두가지 종류로, 가장 작은 단위
    - 스트림 : 여러개의 프레임으로 이루어진 메시지들이 이동하는 연결
    - 여러 스트리으로 구성되어 동시에 여러가지 요청/응답을 처리할 수 있음
- **멀티플렉싱**
    - 파이프라이닝을 개선한 것으로, 선입선출로 처리되던 응답을 비동기방식으로 먼저 처리되는 순서대로 응답을 하는 기술
    - HOL 문제를 해결
- **헤더 압축**
    - 기존의 헤더는 압축없이 전달되었던 것을 가상 테이블을 만들어, 중복전달되는 값들을 기록해 인덱스로 대체해 전달하는 기술
    - 허프만 알고리즘을 활용해 더 경량화 가능
- **서버 푸시**
    - 서버가 클라이언트의 요청 없이도 미리 다음 요청을 예상하고 알아서 응답을 보내는 기술
    - 전체 로딩 완료시간을 크게 줄일 수 있음

## HTTP/3

- UDP를 사용하는 QUIC프로토콜을 사용
- TCP의 오랜 단점을 해결하기 어려워 UDP를 이용한 최적화
- 한번 맺은 QUIC 연결을 최대한 재사용해 연결 시간 대폭 감소
- QUIC (Quick UDP Internet Connections) : OSI 레이어 중 4번째 계층인 전달 계층의 프로토콜
- 전달속도 향상과 클라이언트와 서버의 연결 수를 최소화하고 대역폭을 예상해 패킷 혼잡을 피하는 것이 목적
- Zero RTT : 클라이언트가 이전에 한번이라도 접속했던 서버라면, 별도의 연결없이 바로 데이터를 보내는 기술. 아직 실험단계
- HTTP/2의 TCP HOL 문제를 해결하고, UDP의 빠른 성능, QUIC의 효율성, TLS1.3의 보안성까지 갖춤

## 새로운 프로토콜 적용시 고려할 점

- 사례의 부족과 보안 취약점 등을 조심해야함
- 프론트엔드 최적화 방안도 수정해야함
    - ex. 브라우저의 병렬 다운로드를 통해 도메인 분할 기법을 썼다면 멀티플랙싱 기반의 HTTP/2, 3 사용시 오히려 느려질 수 있음

# **💭 Insights**

### TCP HOL을 어떻게 QUIC에서 해결되었나?

- 우선, TCP에서의 HOL이란, TCP는 스트림을 구분하지 못하고 하나의 패킷으로 인식하므로, 스트림이 여러개여도 TCP 계층에서는 모른다.
- 이때, 여러개의 데이터가 담긴 TCP 패킷에서 특정 스트림의 데이터에 손실이 생기면, TCP는 패킷 전체를 재요청 받기때문에, 나머지 멀쩡한 스트림의 데이터들은 전달되지 못하고 새로운 패킷이 올때까지 남아있다.
- QUIC는 이를 해결하기 위해 독립적인 스트림 관리가 가능하게 설계되었다.
    
    ![대지 1](https://github.com/user-attachments/assets/240d3148-09dd-4303-84f4-d974d7bf1e52)
    <img width="793" alt="스크린샷 2025-01-13 오전 4 16 28" src="https://github.com/user-attachments/assets/c87ca66f-3d45-4cdb-a33a-bdca21e2e8e2" />


- 처음에는 UDP 가 HOL을 해결한 이유라고 생각했는데, 그건 아니었다.
- 그럼 왜 UDP로 한건가?
- QUIC은 UDP 프로토콜 위에서 구현되었는데 사실 말이 UDP지 그 위에다 TCP 프로토콜의 흐름 제어, 오류 제어, 혼잡 제어와 SPDY의 스트림 멀티플렉싱 기능이 모두 구현되어 있다.
- TCP 프로토콜은 OS 커널에 들어있기 때문에 이를 직접 변경하면 모든 네트워크 장비들이 OS 업데이트를 해야 한다.
- 그래서 이미 널리 쓰이고 있는 UDP 위에서 새로운 프로토콜을 구현했다.

    <img width="486" alt="스크린샷 2025-01-13 오전 4 49 02" src="https://github.com/user-attachments/assets/9104a378-8d29-40e7-9d04-6d18ca9bff81" />

