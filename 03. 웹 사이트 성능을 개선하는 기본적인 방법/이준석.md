# **📝 Contents**

## HTTP 요청 수 줄이기

- 웹 페에지에서 요청하는 콘텐츠가 많을수록 로딩 완료시간은 길어짐
- 브라우저의 통신 방식
    1. DNS 시스템으로 특정 도메인의 접속 IP를 알아내 접속
    2. HTML파일 응답을 받음
    3. HTML 내의 CSS나 JS의 콘텐츠를 차례대로 호출함
- 3번에서 콘텐츠를 받아올때, HTML과 콘텐츠의 도메인이 다르면 새로 DNS에서 IP주소를 찾고, 콘텐츠를 다운받는다.

- 스크립트 파일 병합
    - 여러개로 나누어진 js나 css 파일을 하나로 병합해 콘텐츠 요청의 수를 줄이는 방법
    - 그러나 무조건 다 합쳐서 용량이 너무 커지면 로딩과정이 너무 길어질수 있으므로 적잘하게 해야한다.

- 인라인 이미지
    - css 파일안에 이미지파일을 삽입하는 방식
    - 따로 이미지를 받아오는 전통적인 방식보다 로딩시간 단축

- CSS 스프라이트
    - 여러개의 이미지를 하나의 이미지파일로 결합해 필요한 이미지의 픽셀좌표로 사용하는 방식
    - 아이콘같은 작은 이미지 사용시 유리

## 콘텐츠 파일 크기 줄이기

- 파일 크기 자체가 줄면 당연히 로딩 시간도 단축됨

- 스크립트파일 압축 전달
    - HTML, CSS, JS 파일 등을 압축해 전달하는 방법
    - HTTP 프로토콜에서는 헤더에서 Accep-Encoding, Content-Encoding 으로 압축정보를 교환

- 스크립트 파일 최소화
    - 스크립트 파일에서 실제 로직에 영향을 까치지않는 (ex. 주석, 공백)을 제거해 크기를 줄이는 방식
    - 그러나 가독성을 해치므로 개발버전에선 그대로하고, 보통 배포시 줄임

- 이미지파일 압축
    - 이미지의 파일정보인 메타데이터를 제거하거나, 손실압축 등으로 이미지를압축

- 브라우저가 선호하는 이미지 포멧 사용
    - 동일품질이지만 크기를 줄일 수 있는 webp나 jpeg xr등을 사용

- 큰 파일을 작게 나누어 전송
    - 영상을 전체를 보내기보단 시간별로 쪼개 보냄
    - 앞부분부터 로딩이 완료되면 사용자는 바로 콘텐츠 감상 가능
    - HTTP 헤더에 특정 구간을 요청할 수 있음

## 캐시 최적화하기

- 캐시 : 자주 사용되는 콘텐츠나 특정 데이터 등을 임의의 저장소에 복제해두고 재사용하는 방식
- 콘텐츠를 캐시하는 시스템을 프록시서버 라고 부름

- 인터넷 캐시
    - 프록시 서버를 설치해 요청이 많은 곳에서 캐시를 사용
- 브라우저 캐시 사용
    - 사용자의 브라우저에서 직접 캐싱함
    - HTTP헤더에서 cache-control 설정을 통해 캐시를 어떻게 할지 설정 가능

## CDN 사용하기

- Content Delivery Network, 콘텐츠 전송 네트워크는 캐시서버 혹은 엣지서버라 불리는 대용량 캐시 영역에 콘텐츠를 저장해두는 네트워크 방식
- 전세계 인터넷 트래픽 성능을 개선해줌

# **💭 Insights**

### 인라인 이미지

- 따로 이미지를 받아오는 전통적인 방식보다 로딩시간 단축된다는데 그럼 svg처럼 담기는 것인가?
- 근데 보이는 방식은 img태그에 src에 이미지 url을 넣는 것 같다. 무슨 차이인가?
- 아니면 HTML안에 src를 넣어두면 HTML → img 순서로 가져오고,
    
    만약 css에서 src를 정의하면 HTML→ CSS → img 순서여서 더 걸리는 것인가?
    

### webp의 압축 방법

- webp는 기존 jpg와 png에서 부족한 부분들을 보완해주며 압축률이 훨씬 높다.
- 보통 기본적인 압축은 다음 4개의 과정으로 이루어진다.
    
    
    1. 색 공간 변환 (RGB → YCbCr)
        - Y(밝기)와 CbCr(색상 정보)로 나누는 YCbCr 색 공간으로 변환
            
            <img width="829" alt="스크린샷 2024-11-18 오후 5 00 59" src="https://github.com/user-attachments/assets/70305986-f6af-4269-b2f4-83a2b35176db">

    
    1. 크로미넌스 다운샘플링 Chrominance Downsampling 
        - 인간의 눈은 색상보다 밝기에 더 민감하기 때문에, 색상 정보(Cb, Cr)는 더 낮은 정밀도로 저장해도 품질 저하를 적게 느낌
        - CbCr의 정보를 묶어 평균치만 저장
            
            <img width="622" alt="스크린샷 2024-11-18 오후 5 14 32" src="https://github.com/user-attachments/assets/291a9baf-61f7-4494-9c71-580f6ad92eff">

    
    1. 이산 코사인 변환 (DCT)
        - 각 8 x 8 블록으로 분할해, 픽셀 값을 **주파수 성분**으로 변환
        - 이미지의 공간 데이터를 고주파(세부 정보)와 저주파(기본 구조)로 분리
    
    4. 양자화 (Quantization)
    
    - 인간이 고주파 성분(세부적인 변화)에 덜 민감한 점을 이용해, 고주파 데이터를 줄이는 과정
    - 양자화 테이블을 사용하여 각 주파수 성분을 일정한 단계로 분리
    - 작은 값들은 더 크게, 큰 값들은 더 작게 변경
    - 이 단계에서 대부분의 데이터 손실이 발생하지만, 시각적으로는 큰 차이가 느껴지지 않는다.
        
        <img width="844" alt="스크린샷 2024-11-18 오후 5 14 50" src="https://github.com/user-attachments/assets/3a2a403c-28d7-4f47-868b-ae223f50f1fd">
